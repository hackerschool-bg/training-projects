#include "server.hpp"
#include "config.hpp"
#include "logger.hpp"
#include "web_server_utils.hpp"
#include "rapidjson/document.h"
#include <curl/curl.h>
#include <iostream>

rapidjson::Document Config::config;
FileDescriptor Logger::access_log_fd;
std::set<std::string> Logger::selected_error_log_fields;
std::set<std::string> Logger::selected_access_log_fields;
std::map<const err_log_lvl, const std::string> Logger::err_log_lvl_str = {
  { ERROR, "ERROR" },
  { INFO, "INFO" },
  { WARNING, "WARNING" },
  { DEBUG, "DEBUG" },
};

int main (int argc, char** argv) {
  assert(argc == 2);

  const pid_t pid = fork();

  if (pid == 0) { // child process
    // change file mode mask
    // files generated by the web server will be available for everyone to read, write and execute
    umask(0);

    // init config and opening logs for writing
    try {
      Config::init_config(std::string(argv[1]));
      Logger::init_logger();
    } catch (const std::exception& err) {
      std::cerr << "ERROR: init (config and logger): " << err.what() << std::endl;
      return -1;
    }

    // create a unique session id
    if (setsid() < 0) {
      Logger::error(ERROR, {{ MSG, "setsid: " + std::string(std::strerror(errno)) }});
      return -1;
    }

    // change current working directory to a place that is guaranteed to be there
    if (chdir("/") < 0) {
      Logger::error(ERROR, {{ MSG, "chdir: " + std::string(std::strerror(errno)) }});
      return -1;
    }

    // not just closing STDIN and STDOUT, instead closing and opening them as /dev/null fds
    // so that all files that will be opened don't take STDIN and STDOUT's filehandle ids
    {
      constexpr char dev_null_path[] = "/dev/null";
      const int fd = open(static_cast<const char*>(dev_null_path), O_RDWR | O_CLOEXEC, 0);

      if (fd < 0) {
        Logger::error(ERROR, {{ MSG, "open: " + std::string(std::strerror(errno)) }});
        return -1;
      }

      FileDescriptor dev_null_fd(fd);

      if (dup2(dev_null_fd._fd, STDIN_FILENO) < 0) {
        Logger::error(ERROR, {{ MSG, "dup2 (stdin): " + std::string(std::strerror(errno)) }});
        return -1;
      }

      if (dup2(dev_null_fd._fd, STDOUT_FILENO) < 0) {
        Logger::error(ERROR, {{ MSG, "dup2 (stdout): " + std::string(std::strerror(errno)) }});
        return -1;
      }
    }

    try {
      Server server {};
      server.run();
    } catch (const std::exception& err) {
      Logger::error(ERROR, {{ MSG, err.what() }});
      return -1;
    }

    return 0;
  }

  // parent process:

  if (pid < 0) {
    std::cerr << "ERROR: fork: " << std::string(std::strerror(errno)) << std::endl;
    return errno;
  }

  return 0;
}
