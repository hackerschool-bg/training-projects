use strict;
use warnings;
use sigtrap;
use diagnostics;
use lib './';
use POSIX qw();
use Fcntl qw();
use Scalar::Util qw(blessed);
use Server qw(Server);
use ErrorHandling qw(assert);
use ImportConfig;
use Logger;

our %CONFIG;
our ($log, $ERROR, $WARNING, $DEBUG, $INFO);

sub start {
    my $server = new Server();

    eval {
        $server->run();
        1;
    } or do {
        assert(blessed($@) eq 'Error');

        $log->error($ERROR, msg => $@->{msg});
    };

    $server->stop();
}

my $pid = fork();

if (!defined($pid)) {
    die("fork: $!");
}

if ($pid == 0) { # child process
    # change file mode mask
    # files generated by the web server will be available for everyone to read, write and execute
    my $prev_umask = umask(0);

    if (!defined($prev_umask)) {
        die("umask: $!");
    }

    # create a unique session id
    POSIX::setsid();

    # change current working directory to a place that is guaranteed to be there
    chdir('/') or die("chdir: $!");

    # not just closing STDIN and STDOUT, but also redirecting them to /dev/null
    # so that all files that will be opened don't take STDIN and STDOUT's filehandle ids
    sysopen(my $dev_null_fh, '/dev/null', Fcntl::O_RDWR) or die("sysopen: $!");

    POSIX::dup2(fileno($dev_null_fh), fileno(STDIN)) or die("dup2: $!");
    POSIX::dup2(fileno($dev_null_fh), fileno(STDOUT)) or die("dup2: $!");

    close($dev_null_fh) or die("close: $!");

    start();
} else {
    exit(0); # status code: OK
}
